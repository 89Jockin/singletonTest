#三种较为常见单例模式对比


##Singleton.class
该实现方式有几个值得注意的技术点： 
1.	使用双重锁检测机制，确保并发情况下instance对象不会被重复初始化。 
2.	使用volatile修饰符，防止指令重排引发的初始化问题。
	
##SingletonStatic.class
该实现方式有几个需要注意的点： 
1.从外部无法访问静态内部类LazyHolder，只有当调用SingletonStatic.getInstance方法的时候，才能得到单例对象INSTANCE。

2.INSTANCE对象初始化的时机并不是在单例类SingletonStatic被加载的时候，而是在调用getInstance方法，使得静态内部类LazyHolder被加载的时候。因此这种实现方式是利用classloader的加载机制来实现懒加载，并保证构建单例的线程安全。


##SingletonEnum.class

该实现方式是结合了静态内部类，将静态内部类和枚举的有优点结合在一起，保证线程安全。但需要注意的姿势是，它并非使用懒加载，其单例对象是在枚举类被加载的时候进行初始化的。


#几点补充： 
使用枚举实现的单例模式，不但可以防止利用反射强行构建单例对象，而且可以在枚举类对象被反序列化的时候，保证反序列的返回结果是同一对象。 
对于其他方式实现的单例模式，如果既想要做到可序列化，又想要反序列化为同一对象，则必须实现readResolve方法。

```
单例模式实现 | 线程安全 | 懒加载 | 防止反射构建
----------|--------|---------|----------
双重锁检测   |  是     |   是  |  否 静态内部类   |  是     |   是  |  否
 枚举。     |   是    |   否  |  是

```


